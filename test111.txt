private fun makeConverter(task: VideoTranscodingTask): Operator {
    // Step 1: detect transform needs
    val needRotate = task.getRotation() != task.getTranscodingRotation()
    val srcW = task.getVideoWidth()
    val srcH = task.getVideoHeight()

    // Step 2: size after rotation (swap if 90/270)
    val rotatedW = if (needRotate && (task.getRotation() % 180 != 0)) srcH else srcW
    val rotatedH = if (needRotate && (task.getRotation() % 180 != 0)) srcW else srcH

    // Step 3: compute scale and target
    val targetW = task.getTranscodingVideoWidth()
    val targetH = task.getTranscodingVideoHeight()

    // scale to make sure resized >= target in both dims
    val scale = maxOf(targetW.toFloat() / rotatedW, targetH.toFloat() / rotatedH)
    val scaledW = (rotatedW * scale).roundToInt()
    val scaledH = (rotatedH * scale).roundToInt()

    SLog.i(TAG, """makeConverter fixed:
        | src=${srcW}x${srcH} rot=$needRotate(${task.getRotation()})
        | rotated=${rotatedW}x${rotatedH}
        | scaled=${scaledW}x${scaledH}
        | target=${targetW}x${targetH}
    """.trimToOneLine())

    val converters = mutableListOf<ImgpConverter>()

    if (needRotate) converters += ImgpConverter(UniImgp.ofRotate())
    if (scale != 1f) converters += ImgpConverter(UniImgp.ofResize())
    converters += ImgpConverter(UniImgp.ofCrop()) // always safe to crop-center

    return Operator { ibuf, obuf ->
        var input = ibuf
        var output = obuf

        for ((index, converter) in converters.withIndex()) {
            val last = index == converters.lastIndex
            output = when (converter.imgpType) {
                ImgpType.ROTATE -> MediaBuffer.newImageAlloc().apply {
                    val newFmt = input.format.toMutableFormat()
                        .setCols(rotatedW)
                        .setRows(rotatedH)
                        .setRotation(getCorrectionRotation(task.getRotation(), task.getTranscodingRotation()))
                    setMediaFormat(newFmt)
                    if (last && obuf.isNotEmpty) setData(obuf.getData()) else asSharable()
                }.allocate().toMutable()

                ImgpType.RESIZE -> MediaBuffer.newImageAlloc().apply {
                    val newFmt = input.format.toMutableFormat()
                        .setCols(scaledW)
                        .setRows(scaledH)
                    setMediaFormat(newFmt)
                    if (last && obuf.isNotEmpty) setData(obuf.getData()) else asSharable()
                }.allocateMutable()

                ImgpType.CROP -> MediaBuffer.newImageAlloc().apply {
                    // always safe crop (center)
                    val x = ((scaledW - targetW) / 2).coerceAtLeast(0)
                    val y = ((scaledH - targetH) / 2).coerceAtLeast(0)
                    val cropRect = Rect(x, y, x + targetW, y + targetH)

                    val newFmt = input.format.toMutableFormat()
                        .setCols(targetW)
                        .setRows(targetH)
                        .setCropRect(cropRect)

                    setMediaFormat(newFmt)
                    if (last && obuf.isNotEmpty) setData(obuf.getData()) else asSharable()
                }.allocateMutable()

                else -> throw UnsupportedOperationException()
            }

            input = converter.run(input, output)
        }
        output
    }
}
